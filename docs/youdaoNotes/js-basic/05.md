---
title: '函数(二)'
---

## 变量的作用域

在函数内部声明的变量，只能在函数内部使用，在函数外部任何地方都不能够访问。
```js
function fun() {
    // a在函数内部声明的，只能在fun函数内部使用
    var a = 10;
    console.log(a);
}
// a在函数外部不能使用
console.log(a);     // 报错，a is not defined
```

对于 js，只有函数能够关住变量的作用域。

## 局部变量和全局变量

- 局部变量：在一个作用域（定义域）内定义的变量就是这个作用域内的局部变量。只能在作用域内被访问到。
- 全局变量：从广义上来看，全局变量也是一种局部变量。全局变量定义在全局，所以也叫全局变量。可以在任何地方都被访问到。

**变量声明的原理：**

全局变量，在全局定义之后，会永久存在，任何时候，任何位置访问，都能够找到它。局部变量定义在函数内部的，函数定义的过程，并没有真正的去定义这个局部变量，只有在执行函数的时候，才会立即定义这个局部变量，执行完之后，变量就被立即销毁了，在其他的地方访问变量的时候，找不到这个变量，所以会有一个引用错误，变量未定义。

## 形式参数是局部变量

只能在函数的内部访问到，在其他地方不能被访问。

## 全局变量的作用

1. 传递作用

在不同的函数之间可以作为信号量，这些函数都能够改变这个全局变量，并且使用新的值参与计算。

```js
// a是全局变量，任何地方都可以使用
// a称为信号量，不管任何函数改变a的值，都可以记住并且再次使用都是使用a改变之后的新值参与计算
var a = 10;
// 函数使用
function fun() {
    a++;
    console.log(a);
}
// 其他函数也可以使用
function fun2() {
    a--;
    console.log(a);
}
```

2. 通信作用

在同一个函数使用全局变量不会每次都清空，也还是使用新值参与计算。

```js
// 使用全局变量
var a = 1;
// 声明函数
function fun() {
    ++a;
}
fun();
fun();
fun();
fun();
fun();
// 输出新值
console.log(a);    // 打印6
```

## 作用域链

实质指的是查找变量的一个规律，当在一个作用域内，查找不到要使用的变量时，会一层一层地向外查找，遇到了就马上使用，类似于就近原则。

如果变量声明不写 var 关键字，计算机会默认认为它是一个全局变量，这种情况我们要尽量避免，因为这会造成全局变量的污染，定义变量必须书写 var 关键字。

```js
// 全局a
var a = 10;
function fun1() {
    // 函数内部的var省略，强制转为全局变量
    a = 20;
    console.log(a);     // 20
    function fun2() {
        console.log(a); // 20
    }
    fun2();
}
fun1();
console.log(a);         // 20
```

## 函数的作用域

在函数内部声明的变量，只能在函数的内部访问，在其他任何地方都不能够被直接访问。

```js
// 声明函数
function outer() {
    // 函数内部声明一个变量
    var a = 10;
    // 函数内部声明一个函数
    function inner() {
        console.log(a);
    }
    // 调用函数
    inner();
}
// 调用函数
outer();
// inner在函数外部不能使用
inner();

// 最后打印结果为10、inner is not defined
```

## 闭包

函数本身就是一个闭包，函数可以记住自己定义时所处的外部环境和内部语句，这就是闭包。

```js
function outer() {
    var a = 10;
    function inner() {
        console.log(a);
    }
    return inner;
}

// 用i变量接收outer(),相当于把inner函数赋值i
var i = outer();
i();
```

对于上例中的 inner 函数，就很好的说明了这一点。就算把它拿出来了，它还是能够记住自己的外部环境和内部语句。<br>
闭包是函数天生存在的性质，不需要任何的结构，这不过通过这种形式，我们才能够体会到。

```js
// 形参是局部变量
function outer(x) {
    function inner(y) {
        // 当前作用域没有x的定义，使用outer中x
        console.log(x + y);
    }
    // 返回inner的定义
    return inner;
}

// 将outer调用赋值给i，相当于将inner定义赋值的i
// 类似于把inner拿到外部使用，能够记住自己定义时所处的外部环境x = 10
// 类似于把inner拿到外部使用，能够记住自己定义时内部语句console.log(10 + y)
// i = function inner(y) { console.log(10 + y) };
var i = outer(10);
// 调用i函数
i(20, 30, 40);      // 打印30
// 声明一次函数i可以多次调用
i(100);             // 打印110
```
```js
// 闭包：函数能够记住定义时的外部环境和内部语句
function outer(x, y) {
    function inner(y) {
        // 作用域链根据就近原则
        console.log(x + y);
    }
    // 调用outer(x + y)返回的是inner函数
    return inner;
}

// i赋值的是inner函数
var i = outer(1, 2);
// i是inner函数名字，调用i函数，i的实际参数是赋值给inner函数y
// i(10)调用，能够记住x = 1，还可以内部语句console.log(1 + y)
i(10);      // 打印11
i(20);      // 打印21
```
把一个闭包分别赋给两个变量接收，两个闭包之间相互不会影响。

```js
function fun1() {
    var a = 10;
    function fun2() {
        a++;
        console.log(a);
    }
    // 调用fun1返回的是fun2的定义
    return fun2;
}

// 每一次fun1调用都产生一个全新的闭包，之间互不影响
var inn1 = fun1();
var inn2 = fun1();

// 闭包的外部环境不是一成不变的，能够记住当前的新值，并参与计算
inn1();      // 11
inn1();      // 12
inn1();      // 13
inn1();      // 14

// 每一次fun1调用都产生一个全新的闭包，inn1和inn2闭包互不影响
// 每一个闭包，外部环境是全新的内部语句也是全新的
inn2();      // 11
inn2();      // 12
inn1();      // 15
```