---
title: '函数(一)'
---

## 函数声明

函数就是一个功能，函数的声明是告诉我们函数有什么功能语句，并不会执行。<br>
如图，声明了一个 fun 函数：

```js
function fun() {
    // 将功能语句书写在大括号中，表示一个整体
    console.log(1);
    console.log(2);
    console.log(3);
}
```

## 函数调用

函数在声明过后，必须调用才能执行。<br>
语法：

```js
函数名();
```

函数声明一次可以多次调用，利用这一特性在某些情况我们能简化代码书写。

## 参数

包括形式参数和实际参数：

<center>
    <img src="https://mynotes-1257961174.cos.ap-beijing.myqcloud.com/youdaoNotes/js-4/1.jpeg" alt="">
</center>

函数在调用时，将实际参数传递给形式参数的过程就叫做传参。

**2 种特殊情况：**

-   当实际参数数量大于形式参数：

    前面的数依次转递，后面多余的数被舍弃，在代码块内不会执行，但是在 arguments 对象中可以查找到。
-   当实际参数数量小于形式参数：

    还是前面的依次传递，后面没有值传入的形参值为 undefined。

**函数的优点：**

函数可以传参数，就相当于给我们提供了一个 API 接口，我们可以通过接口去传递不同的参数，得到一个经过固定流程处理后的值，那我们可以把它进行封装，用的时候不用知道函数里面的构造执行顺序，只用知道它传入参数的规则，以及得到什么值，就可以了。浏览器和 js 句也提供了很多的封装函数，也就是一些接口，都是一个道理。

## return

可以接收一个参数，作为函数的返回值。返回值并不会自己去输出，想输出查看可以用 console.log。
```js
// 声明函数
function sum(a, b) {
    return a + b;
}
// 调用
sum(2, 5);
```
- return 的特性：

&emsp;&emsp; 函数内部遇到 return 则立即返回，不会再执行后面的其他任何语句。

利用返回值，我们可以把一个函数执行完返回的参数，当作实际参数，传递给另外一个函数。于是我们可以把一个大程序逐步分解，模块化编程。

模块化编程的意义就是把一些比较基础经常使用的公共部分，封装到一个函数里，当我们要使用时，直接调用函数就可以了，不用再把基础的模块再书写一遍，不仅简化代码的书写，而且更便于程序功能的拓展。

- 模块化编程实例：

要求：利用模块化编程输出 1000 以内所有的质数

思考：分三步，倒着分析 → 输出 1000 以内的质数 → 判断是不是质数 → 求任意数字约数总个数

```js
// 1、输出1000以内的质数
for (var i = 1; i <= 1000; i++) {
    if (isZhishu(i)) {
        console.log(i);
    }
}
/**
 * 2、输入数字判断是不是质数
 * 参数：一个数字
 * 返回值：true/false
 */
function isZhishu(a) {
    // 如果是质数true，不是返回false
    if (yueShuGeShu(a) === 2) {
        // 是质数
        return true;
    } else {
        // 不是质数
        return false;
    }
}
/**
 * 3、求任意数字的约数总个数
 * 参数：一个数字
 * 返回值：数字、个数
 */
function yueShuGeShu(num) {
    // 定义累加器
    var sum = 0;
    for (var i = 1; i <= num; i++) {
        // i是约数，sum++
        if (num % i === 0) {
            sum++;
        }
    }
    return sum;
}
```

## 函数表达式

将一个匿名函数赋值给一个变量。
```js
var fun = function () {
    console.log(10);
}
```

## 函数的数据类型

为 function。

数据类型分为简单数据类型和引用数据类型。

- 简单数据类型：变量可以接收任何赋值，可以将变量赋值给另外的一个变量，实质上是将变量保存的值复制一份，变量改变不会互相影响。
- 引用数据类型：变量可以接收任何赋值，可以将变量赋值给另外的一个变量，如果变量保存的是引用数据类型，是将变量的指针复制（地址）指向另一个变量，变量改变会互相影响。

总的来说：简单数据类型复制的是值，引用数据类型复制的是地址。

## 函数的声明的提升

函数就像变量的声明提升一样，会提升到所有语句之前解析，又因为函数保存的是一个指针，能够通过指针找到函数的定义，就相当于函数整体进行了一个提升。

但是如果使用的是函数表达式的方式，函数定义则不会提升，提升的是盛放它的变量容器，如果先调用则会报错。

tips：在声明函数时，最好用 function 这种，不容易出错误，而且我们习惯上先书写函数的调用，将函数的声明放在之后，以便于代码的读取。

实例：
1. 变量名和函数名 function 相同，先提升 function

```js
console.log(fun);   // 这里打印出来的就是下面定义的fun函数
// 后声明
var fun = 10;
function fun() {
    console.log(20);
}
```

2. 函数表达式和 function 同名，也是优先赋予 function

```js
// 先调用
fun();  // 这里调用会打印出2
// 声明
var fun = function () {
    console.log(1);
}
function fun() {
    console.log(2);
}
```

## 递归函数

在函数内部调用自身，一般用来解决数学问题，性能比较差。

实例：菲波那切数列：1,1,2,3,,5,8,13,21,34……

```js
function fiebo(n) {
    // 用户输入第n项，返回对应的值
    // 从第三项开始值等于（n-1）对应的值+（n-2）对应的值
    if (n === 1 || n === 2) {
        return 1;
    } else {
        return fiebo(n - 1) + fiebo(n - 2);
    }
}
```